  进程组和守护进程

jobs查看后台进程
tty查看当前终端名字

pid_t getpgrp(void);
功能:获取当前进程的进程组ID
参数 : 无
返回值 : 总是返回调用者的进程组ID


pid_t getpgid(pid_t pid);
功能:获取指定进程的进程组ID
参数 :
pid:进程号, 如果pid = O, 那么该函数作用和getpgrp一样
返回值 :
成功:进程组ID
失败 : -1


int setpgid(pid_t pid, pid_t pgid);
功能:
改变进程默认所属的进程组。通常可用来加入一个现有的进程组或创建一个新进程组。
参数 :
将参1对应的进程, 加入参2对应的进程组中
返回值 :
成功:0
失败 : -1


会话是一个或者多个进程组的集合
创建会话调用的进程不能是进程组组长进程，也就是说组长不能变会长
一个进程创建会话后，这个进程将成为组长进程




pid_t getsid(pid_t pid);
功能:获取进程所属的会话ID
	返回值 :
	成功 : 返回调用进程的会话ID
	失败 : -1
	组长进程不能成为新会话首进程, 新会话首进程必定会成为组长进程。


		



		pid_t setsid(void);
		创建一个会话, 并以自己的ID设置进程组ID, 同时也是新会话的ID。
		调用了setsid函数的进程,既是新的会长, 也是新的组长。
		参数 : 无
		返回值 :
		成功 : 返回调用进程的会话ID
		失败 : -1
		





在Linux和Unix系统中，每个文件和目录都有相应的文件权限，即对文件或目录的读取、
写入和执行权限。在Linux和Unix系统中，可以使用chmod命令更改文件权限。
而文件权限掩码（umask）则是一种控制文件权限的默认机制，它会在创建新文件或目录时应用。

文件权限掩码指定了在创建新文件或目录时，应该从默认权限中屏蔽掉哪些权限。
例如，如果文件权限掩码为022，则在创建新文件或目录时，会将所有用户组的写权限从默认权限中去掉，
这意味着新文件或目录将具有644或755的默认权限，而不是666或777的权限。

重设文件权限掩码指的是在当前会话中修改文件权限掩码的值。
这可以通过使用umask命令来实现。例如，如果想将文件权限掩码设置为022，
则可以在终端窗口中输入umask 022命令。这将修改当前会话的文件权限掩码，
以便在创建新文件或目录时应用新的权限设置。






在Linux系统中，每个进程都会默认打开3个文件描述符，即标准输入(STDIN_FILENO)、
标准输出(STDOUT_FILENO)和标准错误(STDERR_FILENO)。
此外，进程在执行过程中还会打开其它的文件描述符来读取或写入文件、套接字等等。

当一个进程不再需要某个文件描述符时，为了释放操作系统资源和防止被意外访问敏感信息，
应该及时将其关闭。关闭文件描述符可以通过close()系统调用来实现，例如close(fd)，其中fd是待关闭的文件描述符。

在创建守护进程时，为了避免不必要的文件描述符被继承和占用系统资源，
需要关闭所有不需要的文件描述符，通常包括标准输入、标准输出和标准错误，
以及父进程打开的所有文件描述符。这样可以有效提高守护进程的稳定性和安全性





tail -f  txt     动态查看txt文件的内容




#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
			//创建守护进程
			int main()
		{
			int ret = -1;
			pid_t  pid = -1;
			//1.创建子进程，父进程退出(必须)
			pid = fork();
			if (-1 == pid)
			{
				perror("fork");
				return 1;
			}
			if (pid > 0)
			{
				exit(0);
			}

			//2.创建新的会话,使进程安全脱离控制终端,此时
			//即使退出终端，此进程依然还存在
			pid = setsid();
			if (pid == -1)
			{
				perror("setsid");
				return 1;
			}


			//3.改变当前的工作目录
			ret = chdir("/");
			if (ret == -1)
			{
				perror("chdir");
				return 1;
			}
			//4.设置权限掩码
			umask(0);
			//5.关闭文件描述符
			close(STDIN_FILENO);
			close(STDOUT_FILENO);
			close(STDERR_FILENO);
			//6.执行核心任务
			 //每隔一秒钟输出当前的时间到/tmp/txt.log文件中
			while (1)
			{
				system("date >> /tmp/txt.log");
				sleep(1);
			}

			return 0;
		}
