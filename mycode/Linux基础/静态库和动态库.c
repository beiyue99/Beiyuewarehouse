-E 预处理 发生宏替换，去注释
gcc - E hello.c - o hello.i
- S编译 转化为汇编代码，汇编文件后缀为.s
- c 把汇编文件生成目标文件，目标文件后缀为.o
- o  链接生成可执行文件名字
gcc hello.o - o a.out

gcc - v查看版本号 - g 包含调试信息 - Wall 显示出所有警告, 在后面再接一个 - Werror 如果存在警告则编译不会通过



制作静态库，先生成对应的.o文件，再借助ar工具 将.o文件打包为.a文件 libtest.a，
ar工具的三个参数 ： r：更新  c：创建  s：建立索引 ar - rcs libtest.a add.o sub.o
- I(大写i）指定 头文件的路径
	- L指定连接时需要的库的路径
	- l(小写L)指定链接时所需要的库的名字
	gcc test.c - I. / -L. / -ltest



	制作动态库
	动态库制作，第一步先用fpic生成与地址无关的编译程序.o
	gcc - fpic - c add.c sub.c
	第二步，借助 - shared生成共享库，后缀为.so
	gcc - shared add.o sub.o - o libaa.so
	//这两步可以合并为  gcc -fpic -shared add.c sub.c -o libaa.so
	然后
	gcc test.c - I. / -L. / -laa运行a.out出错
	这是因为连接器找不到库
	解决办法一： 拷贝库
	sudo cp libaa.so / lib 然后不需要指定库位置
	gcc test.c - I. / -laa 此时运行a.out就可以了，但这是临时设置，重启就失效了


	系统加载可执行代码的时候，我们给出了其所依赖库的名字，但还需要知道绝对路径，此时就需要动态载入器。

	解决办法二： export LD_LIBRARY_PATH = $LD_LIBRARY_PATH: / home / wjf / dir1
	然后再执行a.out就不会报错，这是临时设置
	unset LD_LIBRARY_PATH是清除路径
	echo是查看路径

	解决办法三：
	sudo vim ～ / .bashrc   打开配置文件，在最后一行写入路径，保存退出。然后
	source ～ / .bashrc 更新生效，并永久生效


	解决方法四：
	sudo vim / etc / ld.so.conf将路径写入配置文件，然后更新一下，sudo ldconfig


	解决方法五：
	创建符号链接，把当前目录的libaa.so 创建于lib目录







动态链接:不会把代码编译到二进制文件中, 而是在运行时才去加载, 所以只需要维护一个地址
- fPIC产生位置无关的代码
- shared共享
- (小L)指定动态库
- (大i)指定头文件目录, 默认当前目录
- L手动指定库文件搜索目录, 默认只链接共享目录

//静态库编译的时候指定一下库文件所在目录，编译完成之后，可以把库删掉，因为编译的时候，已经把静态库加载到了项目里





/ usr / local / lib 和 / lib 都是存储动态链接库的目录，不过它们的区别如下：

/ usr / local / lib 是用来存储本地安装的软件的库文件，即自行编译安装的软件库，
而不是通过系统包管理器安装的库文件。这个目录通常不包含系统自带的库文件，而是由管理员或用户自己安装的库文件。
/ lib 则是系统自带的库文件所在目录，用来存放操作系统自带的库文件。

如果将库文件放在程序所在目录下，可以确保程序在运行时可以找到库文件，这对于个人编写的小型应用程序是可行的，
但是如果需要在其他程序中重复使用该库文件，就需要在每个程序所在目录下都拷贝一份库文件，这会浪费磁盘空间，并且不方便维护。

相反，如果将库文件放在系统级别的 / usr / local / lib 目录中，其他程序也可以访问该库文件，这可以提高库文件的可重用性，
避免了在多个程序中重复拷贝库文件的麻烦。因此，后续的Makefile将路径添加到该目录




先把include放入 vc++的包含目录，然后把静态库放入vc++的库目录，然后把库名放入链接器、输入下的依赖项，最后把动态库直接粘进去
